<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8" />
        <title>在线加密 HTML 登录框</title>
        <meta name="description" content="使用此工具加密您的HTML代码，生成带密码保护的HTML文件。" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link
            href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
            rel="stylesheet"
            integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
            crossorigin="anonymous"
        />
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"
            integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A=="
            crossorigin="anonymous"
            referrerpolicy="no-referrer"
        />
        <style>
            body {
                font-size: 16px;
                background-color: #f8f9fa;
                padding-top: 1.5rem;
                padding-bottom: 1.5rem;
            }

            .container {
                max-width: 960px;
            }

            .card {
                margin-bottom: 1.5rem;
            }

            .card-header {
                background-color: #e9ecef;
                font-weight: 500;
            }

            .btn-primary {
                background-color: #007bff;
                border-color: #007bff;
            }
            .btn-primary:hover {
                background-color: #0056b3;
                border-color: #0056b3;
            }

            .btn-success {
                background-color: #28a745;
                border-color: #28a745;
            }
            .btn-success:hover {
                background-color: #1e7e34;
                border-color: #1e7e34;
            }
            
            .btn-info {
                 background-color: #17a2b8;
                 border-color: #17a2b8;
            }
            .btn-info:hover {
                background-color: #117a8b;
                border-color: #117a8b;
            }

            pre {
                background-color: #e9ecef;
                padding: 1rem;
                border-radius: 0.25rem;
                word-break: break-all;
                white-space: pre-wrap;
            }

            .footer {
                text-align: center;
                padding: 20px 0;
                margin-top: 2rem;
                color: #6c757d;
                font-size: 0.9em;
            }
            .form-label {
                font-weight: 500;
            }
            #encrypted_html_display {
                max-height: 200px;
                overflow-y: auto;
            }
        </style>
        <link rel="canonical" href="https://translateabook.com/staticrypt/" />
    </head>

    <body>
        <div class="container">
            <header class="text-center mb-4">
                <h1 class="display-5"><i class="fas fa-lock me-2"></i>HTML代码加密登录框</h1>
                <p class="lead">为您的HTML内容设置密码保护，一键生成加密文件。</p>
            </header>

            <div class="card shadow-sm">
                <div class="card-header">
                    <i class="fas fa-cogs me-2"></i>加密设置
                </div>
                <div class="card-body">
                    <form id="encrypt_form">
                        <div class="mb-3">
                            <label for="password" class="form-label">设置登录密码</label>
                            <input
                                type="password"
                                class="form-control"
                                id="password"
                                placeholder="请设置一个强密码"
                                required
                            />
                        </div>

                        <div class="mb-3">
                            <label for="unencrypted_html" class="form-label">输入您的HTML代码</label>
                            <textarea
                                class="form-control"
                                id="unencrypted_html"
                                placeholder="例如: <html><head>...</head><body><h1>受保护的内容</h1></body></html>"
                                rows="8"
                                required
                            ></textarea>
                        </div>

                        <div class="mb-3 form-check">
                            <input type="checkbox" class="form-check-input" id="remember" checked />
                            <label class="form-check-label" for="remember">
                                启用 "记住密码" 功能
                                <small
                                    class="text-muted ms-1"
                                    data-bs-toggle="tooltip"
                                    data-bs-placement="top"
                                    title="密码将在用户输入后以明文形式存储在浏览器的 localStorage 中。可在“更多参数设置”中设置有效期（默认为无限制）。"
                                >
                                    <i class="fas fa-question-circle"></i>
                                </small>
                            </label>
                        </div>

                        <div class="mb-3">
                            <button class="btn btn-info" type="button" data-bs-toggle="collapse" data-bs-target="#extra-options" aria-expanded="false" aria-controls="extra-options">
                                <i class="fas fa-sliders-h me-1"></i> 更多参数设置
                            </button>
                        </div>

                        <div class="collapse" id="extra-options">
                            <div class="card card-body bg-light mb-3">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="template_title" class="form-label">页面标题</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_title"
                                            placeholder="默认: 'Protected Page'"
                                        />
                                    </div>
                                    <div class="col-md-6">
                                        <label for="template_placeholder" class="form-label">密码框提示文字</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_placeholder"
                                            placeholder="默认: 'Password'"
                                        />
                                    </div>
                                    <div class="col-12">
                                        <label for="template_instructions" class="form-label">用户说明</label>
                                        <textarea
                                            class="form-control"
                                            id="template_instructions"
                                            placeholder="默认: 无 (可在此输入提示用户如何操作)"
                                            rows="2"
                                        ></textarea>
                                    </div>
                                    <div class="col-md-6">
                                        <label for="template_remember" class="form-label">"记住密码"复选框文字</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_remember"
                                            placeholder="默认: 'Remember me'"
                                        />
                                    </div>
                                    <div class="col-md-6">
                                        <label for="remember_in_days" class="form-label">"记住密码"有效天数</label>
                                        <input
                                            type="number"
                                            class="form-control"
                                            id="remember_in_days"
                                            step="any"
                                            min="0"
                                            placeholder="默认: 0 (不过期)"
                                        />
                                        <small class="form-text text-muted">
                                            0 或留空表示永不过期。
                                        </small>
                                    </div>
                                    <div class="col-md-4">
                                        <label for="template_button" class="form-label">登录按钮文字</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_button"
                                            placeholder="默认: 'DECRYPT'"
                                        />
                                    </div>
                                    <div class="col-md-4">
                                        <label for="template_color_primary" class="form-label">按钮颜色</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_color_primary"
                                            placeholder="默认: '#4CAF50'"
                                        />
                                    </div>
                                    <div class="col-md-4">
                                        <label for="template_color_secondary" class="form-label">背景强调色</label>
                                        <input
                                            type="text"
                                            class="form-control"
                                            id="template_color_secondary"
                                            placeholder="默认: '#76B852'"
                                        />
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="d-grid">
                            <button class="btn btn-primary btn-lg" type="submit">
                                <i class="fas fa-shield-alt me-2"></i> 生成加密文件
                            </button>
                        </div>
                    </form>
                </div>
            </div>

            <div class="card shadow-sm">
                <div class="card-header">
                    <i class="fas fa-file-code me-2"></i> 加密结果
                </div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="encrypted_html_display" class="form-label">加密后的数据 (用于模板)</label>
                        <pre id="encrypted_html_display">此处将显示加密后的数据字符串...</pre>
                    </div>
                    <a
                        class="btn btn-success w-100"
                        download="encrypted.html"
                        id="download-link"
                        disabled
                    ><i class="fas fa-download me-2"></i>下载加密后的 HTML 文件</a
                    >
                </div>
            </div>
            
            <div class="accordion mb-4" id="accordionExplanation">
              <div class="accordion-item">
                <h2 class="accordion-header" id="headingOne">
                  <button class="accordion-button collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#collapseConcept" aria-expanded="false" aria-controls="collapseConcept">
                    <i class="fas fa-info-circle me-2"></i>概念 / 如何工作?
                  </button>
                </h2>
                <div id="collapseConcept" class="accordion-collapse collapse" aria-labelledby="headingOne" data-bs-parent="#accordionExplanation">
                  <div class="accordion-body">
                    <p>这个工具使用客户端 JavaScript (运行在您的浏览器中) 来加密您提供的 HTML 内容。</p>
                    <ul>
                        <li><strong>密码处理</strong>: 您设置的密码经过 PBKDF2 加盐哈希处理，以增强安全性。</li>
                        <li><strong>加密算法</strong>: 使用 AES-CBC 算法加密您的 HTML 内容。</li>
                        <li><strong>生成文件</strong>: 工具会生成一个新的 HTML 文件。这个文件包含：
                            <ul>
                                <li>一个密码输入框。</li>
                                <li>加密后的 HTML 内容。</li>
                                <li>解密逻辑 (JavaScript)。</li>
                            </ul>
                        </li>
                        <li><strong>解密过程</strong>: 当用户在生成的 HTML 文件中输入正确的密码时，页面内的 JavaScript 会使用该密码（同样经过哈希处理）来解密并显示原始的 HTML 内容。</li>
                        <li><strong>"记住密码"</strong>: 如果启用，哈希后的密码会存储在浏览器的 localStorage 中，方便下次自动登录。</li>
                        <li><strong>安全性</strong>: 加密和解密都在客户端进行，原始 HTML 和密码不会发送到任何服务器。但请注意，最终用户如果能接触到加密文件和解密脚本，理论上仍有被破解的可能（尽管难度较大）。请将其用于保护非高度敏感信息。</li>
                    </ul>
                    <p>这是一个纯前端的解决方案，适用于静态 HTML 页面的简单密码保护。</p>
                  </div>
                </div>
              </div>
            </div>


        </div>

        <footer class="footer">
            <p>© 2025 在线HTML加密工具</p>
            <p><small>请注意: 此工具生成的加密文件依赖客户端JavaScript执行解密。如果用户禁用了JavaScript，则无法查看受保护内容。</small></p>
        </footer>

        <script id="cryptoEngine">
            window.cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

const HexEncoder = {
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },
    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

async function encrypt(msg, hashedPassword) {
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));
    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);
    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);
    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);
    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );
    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

async function hashPassword(password, salt) {
    let hashedPassword = await hashLegacyRound(password, salt);
    hashedPassword = await hashSecondRound(hashedPassword, salt);
    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);
    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );
    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));
    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));
    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let byteArray;
    let parsedInt;
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));
    const randomIndex = parsedInt % possibleCharacters.length;
    return possibleCharacters[randomIndex];
}

function generateRandomString(length) {
    let randomString = "";
    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }
    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
        </script>

        <script id="codec">
            window.codec = ((function(){
  const exports = {};
function init(cryptoEngine) {
    const exports = {};

    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
    }
    exports.encode = encode;

    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);
                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);
                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            return { success: false, message: "Signature mismatch" };
        }
        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
        </script>

        <script id="formater">
            window.formater = ((function(){
  const exports = {};
function renderTemplate(templateString, data) {
    return templateString.replace(/\/\*\[\|\s*(\w+)\s*\|]\*\/\s*0/g, function (_, key) {
        if (!data || data[key] === undefined) {
            return key;
        }
        if (typeof data[key] === "object") {
            return JSON.stringify(data[key]);
        }
        return data[key];
    });
}
exports.renderTemplate = renderTemplate;

  return exports;
})());
        </script>

        <script id="staticrypt">
            window.staticrypt = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;
const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";
const HexEncoder = {
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);
        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },
    stringify: function (bytes) {
        const hexBytes = [];
        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },
    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};
async function encrypt(msg, hashedPassword) {
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));
    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);
    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);
    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);
    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );
    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;
async function hashPassword(password, salt) {
    let hashedPassword = await hashLegacyRound(password, salt);
    hashedPassword = await hashSecondRound(hashedPassword, salt);
    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);
    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );
    return HexEncoder.stringify(new Uint8Array(keyBytes));
}
function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));
    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;
async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));
    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;
function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let byteArray;
    let parsedInt;
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));
    const randomIndex = parsedInt % possibleCharacters.length;
    return possibleCharacters[randomIndex];
}
function generateRandomString(length) {
    let randomString = "";
    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }
    return randomString;
}
exports.generateRandomString = generateRandomString;
  return exports;
})());
const codec = ((function(){
  const exports = {};
function init(cryptoEngine) {
    const exports = {};
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
    }
    exports.encode = encode;
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);
        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);
        if (decryptedHMAC !== encryptedHMAC) {
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);
                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);
                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            return { success: false, message: "Signature mismatch" };
        }
        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;
    return exports;
}
exports.init = init;
  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

function init(staticryptConfig, templateConfig) {
    const exports = {};
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;
        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }
        return true;
    }
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;
    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;
        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);
        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }
        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;
        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }
    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();
        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }
        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }
        return false;
    }
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;
        if (logoutIfNeeded()) {
            return false;
        }
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);
            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }
        const hashedPassword = localStorage.getItem(rememberPassphraseKey);
        if (hashedPassword) {
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }
            return true;
        }
        return false;
    }
    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);
        const urlFragment = window.location.hash.substring(1);
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);
        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;
        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }
        return false;
    }
    return exports;
}
exports.init = init;

  return exports;
})());
        </script>

        <script
            src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
            crossorigin="anonymous"
        ></script>
        <script>
            const encode = codec.init(cryptoEngine).encode;
            let htmlToDownload;

            function getScriptAsString(id) {
                return document.getElementById(id).innerText.replace(/window\.\w+ = /, "");
            }

            function trackEvent(action) {
                const xhr = new XMLHttpRequest();
                xhr.open("POST", "https://zlgpaemmniviswibzuwt.supabase.co/rest/v1/rpc/increment_analytics", true);
                xhr.setRequestHeader("Content-type", "application/json; charset=UTF-8");
                xhr.setRequestHeader(
                    "apikey",
                    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpsZ3BhZW1tbml2aXN3aWJ6dXd0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2NjkxMjM0OTcsImV4cCI6MTk4NDY5OTQ5N30.wNoVDHG7F6INx-IPotMs3fL1nudfaF2qvQDgG-1PhNI"
                );
                xhr.setRequestHeader(
                    "Authorization",
                    "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InpsZ3BhZW1tbml2aXN3aWJ6dXd0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE2NjkxMjM0OTcsImV4cCI6MTk4NDY5OTQ5N30.wNoVDHG7F6INx-IPotMs3fL1nudfaF2qvQDgG-1PhNI"
                );
                xhr.send(
                    JSON.stringify({
                        action_input: action,
                    })
                );
            }

            function setFileToDownload(data) {
                const request = new XMLHttpRequest();
                request.open("GET", "lib/password_template.html", true); // 确保此路径正确
                request.onload = function () {
                    if (request.status >= 200 && request.status < 400) {
                        const renderedTmpl = formater.renderTemplate(request.responseText, data);
                        const downloadLink = document.querySelector("a.download");
                        if (downloadLink) { // 旧版代码中类名是 a.download，新版是 #download-link
                             downloadLink.href = "data:text/html," + encodeURIComponent(renderedTmpl);
                             downloadLink.removeAttribute("disabled");
                        } else { // 兼容新版ID
                            const newDownloadLink = document.getElementById("download-link");
                            if(newDownloadLink){
                                newDownloadLink.href = "data:text/html," + encodeURIComponent(renderedTmpl);
                                newDownloadLink.removeAttribute("disabled");
                            }
                        }
                        htmlToDownload = renderedTmpl;
                    } else {
                        console.error("无法加载密码模板 (lib/password_template.html)。请检查路径和服务状态。");
                        alert("错误：无法加载密码模板。加密文件将无法正确生成。");
                        document.getElementById("encrypted_html_display").textContent = "错误：无法加载密码模板。";
                    }
                };
                request.onerror = function() {
                    console.error("网络错误：无法加载密码模板 (lib/password_template.html)。");
                    alert("网络错误：无法加载密码模板。请检查您的网络连接和模板文件路径。");
                    document.getElementById("encrypted_html_display").textContent = "网络错误：无法加载密码模板。";
                };
                request.send();
            }

            window.onload = function () {
                trackEvent("show_index");
                var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'))
                var tooltipList = tooltipTriggerList.map(function (tooltipTriggerEl) {
                    return new bootstrap.Tooltip(tooltipTriggerEl)
                })
            };

            document.getElementById("encrypt_form").addEventListener("submit", async function (e) {
                e.preventDefault();
                trackEvent("generate_encrypted");

                const unencrypted = document.getElementById("unencrypted_html").value;
                const password = document.getElementById("password").value;

                if (!password || !unencrypted) {
                    alert("密码和HTML代码不能为空！");
                    return;
                }

                const salt = cryptoEngine.generateRandomSalt();
                const encryptedMsg = await encode(unencrypted, password, salt);

                const templateButton = document.getElementById("template_button").value;
                const templateColorPrimary = document.getElementById("template_color_primary").value;
                const templateColorSecondary = document.getElementById("template_color_secondary").value;
                const templateInstructions = document.getElementById("template_instructions").value;
                const isRememberEnabled = document.getElementById("remember").checked;
                const templateTitle = document.getElementById("template_title").value.trim();
                const templatePlaceholder = document.getElementById("template_placeholder").value.trim();
                const rememberDurationInDays = document.getElementById("remember_in_days").value || 0;
                const templateRemember = document.getElementById("template_remember").value;

                const data = {
                    staticrypt_config: {
                        staticryptEncryptedMsgUniqueVariableName: encryptedMsg,
                        isRememberEnabled,
                        rememberDurationInDays: parseFloat(rememberDurationInDays) || 0,
                        staticryptSaltUniqueVariableName: salt,
                    },
                    is_remember_enabled: JSON.stringify(isRememberEnabled),
                    js_staticrypt: getScriptAsString("staticrypt"),
                    template_button: templateButton ? templateButton : "DECRYPT",
                    template_color_primary: templateColorPrimary || "#4CAF50",
                    template_color_secondary: templateColorSecondary || "#76B852",
                    template_instructions: templateInstructions || "",
                    template_placeholder: templatePlaceholder || "Password",
                    template_remember: templateRemember || "Remember me",
                    template_title: templateTitle || "Protected Page",
                };

                document.getElementById("encrypted_html_display").textContent = encryptedMsg;
                setFileToDownload(data);
            });

            document.getElementById("download-link").addEventListener("click", function (e) {
                if (htmlToDownload) {
                    trackEvent("download_encrypted");
                } else {
                    e.preventDefault();
                    alert("请先生成加密文件，然后再下载。");
                    return false;
                }
                return true;
            });
        </script>
    </body>
</html>
